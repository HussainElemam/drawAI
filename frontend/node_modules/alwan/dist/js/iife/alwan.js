var Alwan = (function () {
  'use strict';

  const version = "2.1.1";

  const alwanDefaults = {
    id: "",
    classname: "",
    theme: "light",
    parent: "",
    toggle: true,
    popover: true,
    position: "bottom-start",
    margin: 4,
    preset: true,
    color: "#000",
    default: "#000",
    target: "",
    disabled: false,
    format: "rgb",
    singleInput: false,
    inputs: true,
    opacity: true,
    preview: true,
    copy: true,
    swatches: [],
    toggleSwatches: false,
    closeOnScroll: false,
    i18n: {
      palette: "Color picker",
      buttons: {
        copy: "Copy color to clipboard",
        changeFormat: "Change color format",
        swatch: "Color swatch",
        toggleSwatches: "Toggle Swatches"
      },
      sliders: {
        hue: "Change hue",
        alpha: "Change opacity"
      }
    }
  };

  const clipboardSVG = `<svg width="18" height="18" viewBox="0 0 24 24" aria-role="none"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg>`;
  const checkSVG = `<svg width="18" height="18" viewBox="0 0 24 24" aria-role="none"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"></path></svg>`;
  const switchInputsSVG = `<svg width="15" height="15" viewBox="0 0 20 20" aria-role="none"><path d="M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z"></path></svg>`;
  const caretSVG = `<svg width="20" height="20" viewBox="0 0 24 24" aria-role="none"><path d="M6.984 14.016l5.016-5.016 5.016 5.016h-10.031z"></path></svg>`;

  const int = parseInt;
  const {
    min,
    max,
    abs,
    round,
    PI
  } = Math;
  const clamp = (value, end = 100, start = 0) => value > end ? end : value < start ? start : value;
  const normalizeAngle = angle => {
    angle %= 360;
    return round(angle < 0 ? angle + 360 : angle);
  };

  const ROOT = document;
  const DOC_ELEMENT = ROOT.documentElement;
  const DEFAULT_COLOR = "#000";
  const BUTTON = "button";
  const OPEN = "open";
  const CLOSE = "close";
  const COLOR = "color";
  const CLICK = "click";
  const POINTER_DOWN = "pointerdown";
  const POINTER_MOVE = "pointermove";
  const POINTER_UP = "pointerup";
  const SCROLL = "scroll";
  const RESIZE = "resize";
  const KEY_DOWN = "keydown";
  const INPUT = "input";
  const CHANGE = "change";
  const BLUR = "blur";
  const FOCUS_IN = "focusin";
  const MOUSE_OUT = "mouseout";
  const HEX_FORMAT = "hex";
  const RGB_FORMAT = "rgb";
  const HSL_FORMAT = "hsl";
  const TAB = "Tab";
  const ESCAPE = "Escape";
  const ENTER = "Enter";
  const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];
  const ARIA_LABEL = "aria-label";

  // Arrow keys move steps.
  const ARROW_KEYS = {
    ArrowUp: [0, -1],
    ArrowDown: [0, 1],
    ArrowRight: [1, 0],
    ArrowLeft: [-1, 0]
  };
  const ANGLE_COEFFICIENT_MAP = {
    deg: 1,
    turn: 360,
    rad: 180 / PI,
    grad: 0.9
  };
  const HSL_REGEX = /^hsla?\(\s*([+-]?\d*\.?\d+)(\w*)?\s*[\s,]\s*([+-]?\d*\.?\d+)%?\s*,?\s*([+-]?\d*\.?\d+)%?(?:\s*[\/,]\s*([+-]?\d*\.?\d+)(%)?)?\s*\)?$/;

  const stringify = (color, format = RGB_FORMAT) => {
    let a = color.a;
    let opacity = "";
    let str = format;
    if (a < 1) {
      opacity += ", " + a;
      str += "a";
    }
    if (format === RGB_FORMAT) {
      return str + `(${color.r}, ${color.g}, ${color.b + opacity})`;
    }
    return str + `(${color.h}, ${color.s}%, ${color.l}%${opacity})`;
  };

  const ALWAN_CLASSNAME = "alwan";
  const CONTAINER_CLASSNAME = `${ALWAN_CLASSNAME}__container`;
  const PALETTE_CLASSNAME = `${ALWAN_CLASSNAME}__palette`;
  const MARKER_CLASSNAME = `${ALWAN_CLASSNAME}__marker`;
  const PREVIEW_CLASSNAME = `${ALWAN_CLASSNAME}__preview`;
  const BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__button`;
  const COPY_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__copy-button`;
  const SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider`;
  const HUE_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__hue`;
  const ALPHA_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__alpha`;
  const INPUT_CLASSNAME = `${ALWAN_CLASSNAME}__input`;
  const INPUTS_CLASSNAME = `${ALWAN_CLASSNAME}__inputs`;
  const SWATCH_CLASSNAME = `${ALWAN_CLASSNAME}__swatch`;
  const SWATCHES_CLASSNAME = `${ALWAN_CLASSNAME}__swatches`;
  const REFERENCE_CLASSNAME = `${ALWAN_CLASSNAME}__reference`;
  const BACKDROP_CLASSNAME = `${ALWAN_CLASSNAME}__backdrop`;
  const COLLAPSE_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__toggle-button`;
  const OPEN_CLASSNAME = `${ALWAN_CLASSNAME}--open`;
  const COLLAPSE_CLASSNAME = `${ALWAN_CLASSNAME}--collapse`;

  const addEvent = (target, type, listener, options) => target.addEventListener(type, listener, options);
  const removeEvent = (target, type, listener) => target.removeEventListener(type, listener);

  const isString = value => typeof value === "string";
  const isset = value => value != null;
  const isElement = value => value instanceof Element;
  const isNumber = value => Number.isFinite(isString(value) && value.trim() !== "" ? +value : value);
  const isFunction = value => typeof value === "function";
  const isHex = value => /^[\da-f]+$/i.test(value);

  const {
    keys,
    assign: merge,
    setPrototypeOf,
    prototype
  } = Object;
  const {
    from: toArray,
    isArray
  } = Array;
  const isPlainObject = obj => isset(obj) && typeof obj === "object" && !isArray(obj) && !isElement(obj);
  const ObjectForEach = (object, callbackFn) => keys(object).forEach(key => callbackFn(key, object[key]));
  const deepMerge = (target, source) => {
    if (!isPlainObject(target)) {
      target = {};
    }
    ObjectForEach(source, (key, value) => {
      if (isset(value)) {
        merge(target, {
          [key]: isPlainObject(value) ? deepMerge(target[key] || {}, value) : value
        });
      }
    });
    return target;
  };

  const getBody = () => ROOT.body;
  const getElements = (reference, context = DOC_ELEMENT) => {
    if (isString(reference) && reference.trim()) {
      return toArray(context.querySelectorAll(reference));
    }
    // Reference must be an element in the page.
    if (isElement(reference)) {
      return [reference];
    }
    return [];
  };
  const getInteractiveElements = context => getElements(`${INPUT},${BUTTON},[tabindex]`, context);
  const appendChildren = (element, ...children) => element.append(...children.filter(child => child));
  const setInnerHTML = (element, html) => {
    element.innerHTML = html;
  };
  const setAttribute = (el, name, value) => {
    if (el && (isNumber(value) || value)) {
      el.setAttribute(name, value + "");
    }
  };
  const joinClassnames = (...classnames) => classnames.join(" ").trim();
  const createElement = (tagName, className, children = [], content, attributes) => {
    const element = ROOT.createElement(tagName);
    if (className) {
      element.className = className;
    }
    if (content) {
      setInnerHTML(element, content);
    }
    ObjectForEach(attributes || {}, (name, value) => setAttribute(element, name, value));
    appendChildren(element, ...children);
    return element;
  };
  const createDivElement = (classname, ...children) => createElement("div", classname, children);
  const removeElement = element => element.remove();
  const replaceElement = (element, replacement) => {
    element.replaceWith(replacement);
    return replacement;
  };
  const createButton = (label = "", className = "", content, title = label) => {
    return createElement(BUTTON, joinClassnames(BUTTON_CLASSNAME, className), [], content, {
      type: BUTTON,
      [ARIA_LABEL]: label,
      title
    });
  };
  const createSlider = (classname, max, step = 1) => createElement(INPUT, joinClassnames(SLIDER_CLASSNAME, classname), [], "", {
    max,
    step,
    type: "range"
  });
  const setCustomProperty = (element, property, value) => {
    if (element) {
      element.style.setProperty("--" + property, value + "");
    }
    return element;
  };
  const toggleClassName = (element, token, forced) => element.classList.toggle(token, forced);
  const translate = (element, x, y) => {
    element.style.transform = `translate(${x}px,${y}px)`;
  };
  const getParentElement = element => element && element.parentElement || getBody();
  const getBoundingRectArray = (element, addClientArea) => {
    let x, y, width, height, right, bottom;
    if (!isElement(element)) {
      x = y = 0;
      width = right = DOC_ELEMENT.clientWidth;
      height = bottom = DOC_ELEMENT.clientHeight;
    } else {
      ({
        x,
        y,
        width,
        height,
        right,
        bottom
      } = element.getBoundingClientRect());
      if (addClientArea) {
        x += element.clientTop;
        y += element.clientLeft;
      }
    }
    return [x, y, width, height, right, bottom];
  };
  const getShadowRoot = node => {
    if (!node || node === getBody()) {
      return null;
    }
    if (node instanceof ShadowRoot) {
      return node;
    }
    return getShadowRoot(node.parentNode);
  };

  const Inputs = alwan => {
    let {
      config,
      _color: colorState
    } = alwan;
    let container;
    let inputsWrapper;
    let switchButton;
    let formats = [];
    let currentFormatIndex;
    let inputsMap;
    let isChanged = false;
    let isSingle;
    const handleChange = () => {
      let color = {};
      let format = formats[currentFormatIndex];
      if (!isChanged) {
        colorState._cache();
        isChanged = true;
      }
      ObjectForEach(inputsMap, (key, input) => color[key] = input.value);
      colorState._setColor(isSingle ? color[format] : stringify(color, format), true);
    };
    const buildInputs = () => {
      if (inputsWrapper) {
        inputsMap = {};
        // Remove all inputs.
        setInnerHTML(inputsWrapper, "");
        isSingle = formats[currentFormatIndex] === HEX_FORMAT || config.singleInput;
        const format = formats[currentFormatIndex];
        // For multiple inputs, each character in the color format represent an input field.
        const fields = isSingle ? [format] : (format + (config.opacity ? "a" : "")).split("");
        const colorValue = colorState._value;
        appendChildren(inputsWrapper, ...fields.map(field => {
          inputsMap[field] = createElement(INPUT, INPUT_CLASSNAME, [], "", {
            type: "text",
            value: colorValue[field]
          });
          return createElement("label", "", [inputsMap[field], createElement("span", "", [], field)]);
        }));
      }
    };
    const changeFormat = () => {
      currentFormatIndex = (currentFormatIndex + 1) % formats.length;
      colorState._setFormat(formats[currentFormatIndex]);
      buildInputs();
    };
    return {
      _init({
        inputs,
        format,
        i18n
      }) {
        container = inputsWrapper = switchButton = null;
        formats = COLOR_FORMATS;
        if (inputs !== true) {
          inputs = inputs || {};
          formats = formats.filter(format => inputs[format]);
        }
        const formatsLength = formats.length;
        if (!formatsLength) {
          formats = COLOR_FORMATS;
        }
        // validate the format option.
        currentFormatIndex = max(formats.indexOf(format), 0);
        colorState._setFormat(formats[currentFormatIndex]);
        if (formatsLength) {
          if (formatsLength > 1) {
            switchButton = createButton(i18n.buttons.changeFormat, "", switchInputsSVG);
            addEvent(switchButton, CLICK, changeFormat);
          }
          inputsWrapper = createDivElement(INPUTS_CLASSNAME);
          container = createDivElement(CONTAINER_CLASSNAME, inputsWrapper, switchButton);
          addEvent(inputsWrapper, INPUT, handleChange);
          addEvent(inputsWrapper, CHANGE, () => {
            colorState._change();
            isChanged = false;
          });
          addEvent(inputsWrapper, FOCUS_IN, e => e.target.select());
          // Pressing Enter causes the picker to close.
          addEvent(inputsWrapper, KEY_DOWN, e => e.key === ENTER && alwan._app._toggle(false));
          buildInputs();
        }
        return container;
      },
      _setValues(color) {
        if (!isChanged) {
          ObjectForEach(inputsMap || {}, (key, input) => input.value = color[key] + "");
        }
      }
    };
  };

  /**
   * Color picking area.
   */
  const Palette = ({
    _color: colorState
  }) => {
    let markerX;
    let markerY;
    let paletteRect;
    let isDisabled;
    const marker = createDivElement(MARKER_CLASSNAME);
    const palette = createDivElement(PALETTE_CLASSNAME, marker);
    const value = {
      s: 0,
      l: 0
    };

    /**
     * Moves marker using a pointer (mouse, touch or pen) or keyboard arrow keys.
     */
    const moveMarkerAndUpdateColor = (e, [stepX, stepY] = [0, 0]) => {
      let [x, y, width, height] = paletteRect;
      let v, l;
      if (e) {
        markerX = e.clientX - x;
        markerY = e.clientY - y;
      } else {
        markerX += stepX * width / 100;
        markerY += stepY * height / 100;
      }
      markerX = clamp(markerX, width);
      markerY = clamp(markerY, height);
      translate(marker, markerX, markerY);
      v = 1 - markerY / height;
      l = v * (1 - markerX / (2 * width));
      value.s = l === 1 || l === 0 ? 0 : (v - l) / min(l, 1 - l) * 100;
      value.l = l * 100;
      colorState._update(value);
    };
    const dragMove = e => {
      if (e.buttons) {
        moveMarkerAndUpdateColor(e);
      } else {
        // Stop dragging if the pointer became not active without triggering
        // the pointerup event.
        setDragging(false);
      }
    };
    const dragEnd = () => {
      colorState._change();
      setDragging(false);
    };

    /**
     * Handles window loses focus while dragging the marker.
     */
    const windowBlur = () => colorState._change();
    const setDragging = dragging => {
      toggleClassName(DOC_ELEMENT, BACKDROP_CLASSNAME, dragging);
      (dragging ? addEvent : removeEvent)(ROOT, POINTER_MOVE, dragMove);
      (dragging ? addEvent : removeEvent)(window, BLUR, windowBlur);
    };
    addEvent(palette, POINTER_DOWN, e => {
      if (!isDisabled) {
        // Drag start.
        colorState._cache();
        paletteRect = getBoundingRectArray(palette);
        moveMarkerAndUpdateColor(e);
        // Drag move.
        setDragging(true);
        // Drag end.
        addEvent(ROOT, POINTER_UP, dragEnd, {
          once: true
        });
      }
    });

    /**
     * Moves marker using keyboard arrow keys.
     */
    addEvent(palette, KEY_DOWN, e => {
      const steps = ARROW_KEYS[e.key];
      if (steps) {
        e.preventDefault();
        paletteRect = getBoundingRectArray(palette);
        colorState._cache();
        moveMarkerAndUpdateColor(null, steps);
        colorState._change();
      }
    });
    return {
      _init({
        i18n,
        disabled
      }) {
        setAttribute(palette, ARIA_LABEL, i18n.palette);
        setAttribute(palette, "tabindex", disabled ? "" : 0);
        isDisabled = disabled;
        return palette;
      },
      _updateMarker(s, l) {
        l /= 100;
        s = l + s / 100 * min(l, 1 - l);
        paletteRect = getBoundingRectArray(palette);
        markerX = (s ? 2 * (1 - l / s) : 0) * paletteRect[2];
        markerY = (1 - s) * paletteRect[3];
        translate(marker, markerX, markerY);
      }
    };
  };

  const Reference = (alwan, element) => {
    let refElement;
    const body = getBody();
    const userRef = element && element !== body && element !== DOC_ELEMENT ? element : null;
    const handleClick = () => alwan._app._toggle();
    if (userRef) {
      refElement = userRef;
    } else {
      refElement = createButton();
      appendChildren(body, refElement);
    }
    return {
      _init({
        preset,
        classname
      }) {
        // userRef !== element means preset button is not set.
        if (userRef && preset != (userRef !== refElement)) {
          if (preset) {
            // Replace user reference with a preset button.
            refElement = replaceElement(userRef, createButton());
            if (userRef.id) {
              refElement.id = userRef.id;
            }
          } else {
            // Replace preset button with the user reference.
            refElement = replaceElement(refElement, userRef);
          }
        }
        addEvent(refElement, CLICK, handleClick);

        // Add classes to the preset button.
        if (!userRef || preset) {
          refElement.className = joinClassnames(BUTTON_CLASSNAME, REFERENCE_CLASSNAME, isString(classname) ? classname : "");
        }
        return refElement;
      },
      _destroy() {
        if (userRef) {
          removeEvent(userRef, CLICK, handleClick);
          if (userRef !== refElement) {
            replaceElement(refElement, userRef);
          }
        } else {
          removeElement(refElement);
        }
      }
    };
  };

  const Sliders = ({
    _color: colorState,
    _events
  }) => {
    let alphaSlider;
    let container;
    const hueSlider = createSlider(HUE_SLIDER_CLASSNAME, 360);

    // Handles hue slider change.
    addEvent(hueSlider, INPUT, () => colorState._update({
      h: +hueSlider.value
    }));
    return {
      _init({
        opacity,
        i18n: {
          sliders
        }
      }) {
        alphaSlider = null;
        if (opacity) {
          alphaSlider = createSlider(ALPHA_SLIDER_CLASSNAME, 1, 0.01);
          // Handles alpha slider change.
          addEvent(alphaSlider, INPUT, () => colorState._update({
            a: +alphaSlider.value
          }));
        } else {
          colorState._value.a = 1;
        }
        setAttribute(hueSlider, ARIA_LABEL, sliders.hue);
        setAttribute(alphaSlider, ARIA_LABEL, sliders.alpha);
        container = createDivElement("", hueSlider, alphaSlider);
        // Handles sliders change stop.
        addEvent(container, CHANGE, () => _events._emit(CHANGE));
        return container;
      },
      _setValues(h, a) {
        hueSlider.value = h + "";
        if (alphaSlider) {
          alphaSlider.value = a + "";
        }
      }
    };
  };

  const ctx = createElement("canvas").getContext("2d");

  /**
   * Parses any value into an RGB or HSL objects.
   * Invalid values default to DEFAULT_COLOR in globals.
   */
  const parseColor = (color, asString) => {
    let format;
    let parsedColor;
    let str = "";
    if (isString(color)) {
      str = color.trim();
    } else {
      if (isPlainObject(color)) {
        format = [RGB_FORMAT, HSL_FORMAT].find(format => format.split("").every(key => isNumber(color[key])));
        if (format) {
          str = stringify(color, format);
        }
      }
    }
    const [isHSL, h, angle, s, l, a = "1", percentage] = HSL_REGEX.exec(str) || [];
    if (isHSL) {
      // Normalize values.
      parsedColor = {
        h: normalizeAngle(+h * (ANGLE_COEFFICIENT_MAP[angle] ? ANGLE_COEFFICIENT_MAP[angle] : 1)),
        s: clamp(+s),
        l: clamp(+l),
        a: clamp(+a / (percentage ? 100 : 1), 1)
      };
      format = HSL_FORMAT;
    } else {
      format = RGB_FORMAT;

      // # is optional.
      if (isHex(str)) {
        str = "#" + str;
      }
      ctx.fillStyle = DEFAULT_COLOR;
      ctx.fillStyle = str;
      // color is rgb or hex string.
      str = ctx.fillStyle;
      if (str[0] === "#") {
        parsedColor = {
          r: int(str.slice(1, 3), 16),
          g: int(str.slice(3, 5), 16),
          b: int(str.slice(5, 7), 16),
          a: 1
        };
      } else {
        const [r, g, b, a] = /\((.+)\)/.exec(str)[1].split(",").map(value => +value);
        parsedColor = {
          r,
          g,
          b,
          a
        };
      }
    }
    // Round the transparency component to two numbers behind
    parsedColor.a = round(parsedColor.a * 100) / 100;
    return asString ? stringify(parsedColor, format) : [parsedColor, format];
  };

  const Swatches = alwan => {
    let container;
    let swatchesContainer;
    let collapseButton;
    let isCollapsed = false;
    return {
      _init({
        swatches,
        toggleSwatches,
        i18n: {
          buttons
        }
      }) {
        if (!isArray(swatches)) {
          return container;
        }
        container = swatchesContainer = collapseButton = null;
        if (!swatches.length) {
          return container;
        }
        swatchesContainer = container = createDivElement(joinClassnames(SWATCHES_CLASSNAME, toggleSwatches && isCollapsed ? COLLAPSE_CLASSNAME : ""), ...swatches.map(color =>
        // Sets custom property on the created button and returns it (the button).
        setCustomProperty(createButton(buttons.swatch, SWATCH_CLASSNAME, "", isString(color) ? color : parseColor(color, true)), COLOR, parseColor(color, true))));
        if (toggleSwatches) {
          collapseButton = createButton(buttons.toggleSwatches, COLLAPSE_BUTTON_CLASSNAME, caretSVG);
          // Handles toggle swatches button click.
          addEvent(collapseButton, CLICK, () => {
            isCollapsed = !isCollapsed;
            toggleClassName(swatchesContainer, COLLAPSE_CLASSNAME, isCollapsed);
            alwan._app._reposition();
          });
          container = createDivElement("", swatchesContainer, collapseButton);
        }

        // Handles clicks in the swatches container.
        addEvent(swatchesContainer, CLICK, ({
          target
        }) => {
          if (target !== swatchesContainer) {
            alwan._color._setColor(target.style.getPropertyValue("--" + COLOR), true, true);
          }
        });
        return container;
      }
    };
  };

  /**
   * Color preview and copy Button.
   */
  const Utility = alwan => {
    let previewElement;
    let copyButton;
    let isCopied = false;
    const setButtonIcon = state => {
      isCopied = state;
      setInnerHTML(copyButton, state ? checkSVG : clipboardSVG);
    };
    const fallback = color => {
      const input = createElement(INPUT);
      appendChildren(DOC_ELEMENT, input);
      input.value = color;
      input.select();
      ROOT.execCommand("copy");
      removeElement(input);
      copyButton.focus();
      // change icon.
      setButtonIcon(true);
    };
    const copyColor = () => {
      if (!isCopied) {
        const clipboard = navigator.clipboard;
        const color = alwan._color._getColorString();
        if (clipboard) {
          clipboard.writeText(color).then(() => setButtonIcon(true)).catch(() => fallback(color));
        } else {
          fallback(color);
        }
      }
    };
    return {
      _init({
        preview,
        copy,
        i18n
      }) {
        previewElement = copyButton = null;
        if (copy) {
          copyButton = createButton(i18n.buttons.copy, COPY_BUTTON_CLASSNAME, clipboardSVG);
          addEvent(copyButton, CLICK, copyColor);
          // Reset clipboard icon.
          addEvent(copyButton, BLUR, () => isCopied && setButtonIcon(false));
          addEvent(copyButton, MOUSE_OUT, () => copyButton.blur());
        }
        if (preview) {
          previewElement = createDivElement(PREVIEW_CLASSNAME, copyButton);
        }
        return previewElement || copyButton;
      }
    };
  };

  // Indexes in the DOMRectArray.
  const LEFT = 0; // Also the x coordinate.
  const TOP = 1; // Also the y coordinate.
  const HEIGHT = 3;
  const RIGHT = 4;
  const BOTTOM = 5;
  const START = 0;
  const CENTER = 1;
  const END = 2;
  // Margin between the popover and the window edges.
  const GAP = 3;

  // Sides to fallback to for each side.
  const fallbackSides = {
    top: [TOP, BOTTOM, RIGHT, LEFT],
    bottom: [BOTTOM, TOP, RIGHT, LEFT],
    right: [RIGHT, LEFT, TOP, BOTTOM],
    left: [LEFT, RIGHT, TOP, BOTTOM]
  };

  // Alignments to fallback to for each alignment.
  const fallbackAlignments = {
    start: [START, CENTER, END],
    center: [CENTER, START, END],
    end: [END, CENTER, START]
  };

  const isInViewport = (target, overflowAncestors) => {
    return overflowAncestors.every(ancestor => {
      const [x, y,,, right, bottom] = getBoundingRectArray(target);
      const [ancestorX, ancestorY,,, ancestorRight, ancestorBottom] = getBoundingRectArray(ancestor);
      return y < ancestorBottom && bottom > ancestorY && x < ancestorRight && right > ancestorX;
    });
  };
  const isContainingBlock = element => {
    const isWebkit = !(typeof CSS === "undefined" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
    const {
      transform,
      perspective,
      filter,
      containerType,
      backdropFilter,
      willChange = "",
      contain = ""
    } = getComputedStyle(element);
    return transform !== "none" || perspective !== "none" || containerType !== "normal" || !isWebkit && backdropFilter !== "none" || !isWebkit && filter !== "none" || /transform|perspective|filter/.test(willChange) || /paint|layout|strict|content/.test(contain);
  };
  const getOverflowAncestors = (element, ancestors = [ROOT]) => {
    element = getParentElement(element);
    if (element === getBody()) {
      return ancestors;
    }
    const {
      display,
      overflow
    } = getComputedStyle(element);
    if (/auto|scroll|overflow|clip|hidden/.test(overflow) && !["inline", "contents"].includes(display)) {
      ancestors.push(element);
    }
    return getOverflowAncestors(element, ancestors);
  };
  const getOffsetParent = element => {
    element = getParentElement(element);
    if (isContainingBlock(element)) {
      return element;
    }
    if (element === DOC_ELEMENT || isTopLayer(element)) {
      return ROOT;
    }
    return getOffsetParent(element);
  };
  const topLayerSelectors = [":popover-open", ":modal"];
  const isTopLayer = element => topLayerSelectors.some(selector => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });

  const createPopover = (target, popoverElement, alwanReferenceElement, {
    margin,
    position,
    toggle,
    closeOnScroll
  }, {
    _isOpen,
    _toggle
  }) => {
    margin = isNumber(margin) ? +margin : 0;
    const [side, alignment] = isString(position) ? position.split("-") : [];
    const sidesFlipOrder = fallbackSides[side] || fallbackSides.bottom;
    const alignmentsFlipOrder = fallbackAlignments[alignment] || fallbackAlignments.center;
    const overflowAncestors = getOverflowAncestors(target);
    const popoverStyleDeclaration = popoverElement.style;
    const shadowRoot = getShadowRoot(alwanReferenceElement);
    const setPosition = () => {
      popoverStyleDeclaration.height = "";
      const viewportRect = getBoundingRectArray(ROOT);
      const targetRect = getBoundingRectArray(target);
      const popoverRect = getBoundingRectArray(popoverElement);
      const offsetParentRect = getBoundingRectArray(getOffsetParent(popoverElement), true);
      const coordinates = [null, null];
      sidesFlipOrder.some(side => {
        // Get the axis from the side.
        // 0 (horizontal) if the side is LEFT (1) or RIGHT (4).
        // 1 (vertical) if the side is TOP (0) or BOTTOM (5).
        let axis = side % 2;
        const viewportSide = viewportRect[side];
        const targetSide = targetRect[side];
        // axis + 2 gives the dimension based on the axis,
        // x => width or y => height.
        const spaceForPopover = margin + popoverRect[axis + 2];
        if (spaceForPopover > abs(viewportSide - targetSide)) {
          return false;
        }
        coordinates[axis] = targetSide + (side <= 1 ? -spaceForPopover : margin);

        // Reverse the axis for the alignments.
        axis = (axis + 1) % 2;

        // start => top or left positions.
        // end => bottom or right positions.

        const endCoordinateIndex = axis + 4;
        const dimensionIndex = axis + 2;
        const popoverDimension = popoverRect[dimensionIndex];
        const targetStart = targetRect[axis];
        const targetEnd = targetRect[endCoordinateIndex];
        const viewportEnd = viewportRect[endCoordinateIndex] - targetStart;
        const offset = (popoverDimension + targetRect[dimensionIndex]) / 2;
        alignmentsFlipOrder.some(alignment => {
          if (alignment == START && popoverDimension <= viewportEnd) {
            coordinates[axis] = targetStart;
            return true;
          }
          if (alignment == CENTER && offset <= targetEnd && offset <= viewportEnd) {
            coordinates[axis] = targetEnd - offset;
            return true;
          }
          if (alignment == END && popoverDimension <= targetEnd) {
            coordinates[axis] = targetEnd - popoverDimension;
            return true;
          }
          return false;
        });
        return true;
      });
      translate(popoverElement, ...coordinates.map((value, axis) => {
        // Set a dynamic height if the popover height is greater than
        // the viewport height.
        if (axis && value === null && popoverRect[HEIGHT] > viewportRect[BOTTOM]) {
          popoverStyleDeclaration.height = viewportRect[BOTTOM] - GAP * 2 + "px";
          popoverRect[HEIGHT] = viewportRect[BOTTOM] - GAP;
        }
        return round((isset(value) ? value :
        // center the popover relative to the viewport.
        (viewportRect[axis + 4] - popoverRect[axis + 2]) / 2) - offsetParentRect[axis]);
      }));
    };
    const autoUpdatePosition = ({
      type
    }) => {
      if (_isOpen() || !toggle) {
        if (isInViewport(target, overflowAncestors)) {
          if (_isOpen()) {
            setPosition();
            if (closeOnScroll && type === SCROLL) {
              _toggle(false);
            }
          } else {
            // This is reachable only if toggle is false.
            // open picker if the reference becomes visible.
            _toggle(true, true);
          }
        } else {
          // close picker even if the toggle option was set to false.
          _toggle(false, true);
        }
      }
    };

    // Keyboard accessibility.
    const handleKeyboard = e => {
      if (_isOpen()) {
        const {
          target,
          key,
          shiftKey
        } = e;
        if (key === ESCAPE) {
          // Close the picker.
          _toggle(false);
        } else if (key === TAB) {
          const focusableElements = getInteractiveElements(popoverElement);
          const firstFocusableElement = focusableElements[0];
          const hasTabbedToPopover = target === alwanReferenceElement && !shiftKey;
          const hasTabbedAwayFromPopover = shiftKey && target === firstFocusableElement || !shiftKey && target === focusableElements.pop();
          const elementToFocusOn = hasTabbedToPopover ? firstFocusableElement : hasTabbedAwayFromPopover ? alwanReferenceElement : null;
          if (elementToFocusOn) {
            e.preventDefault();
            elementToFocusOn.focus();
          }
        }
      }
    };

    /**
     * Clicks outside of the popover.
     */
    const handleBackdropClick = ({
      target
    }) => {
      if (_isOpen() && (
      // Alwan reference element in a shadow dom and target is the shadow root.
      !shadowRoot || target !== shadowRoot.host) && target !== alwanReferenceElement && !popoverElement.contains(target) && !toArray(alwanReferenceElement.labels || []).some(label => label.contains(target))) {
        _toggle(false);
      }
    };

    /**
     * Adds/Removes events.
     */
    const togglePopoverEvents = fn => {
      overflowAncestors.forEach(ancestor => fn(ancestor, SCROLL, autoUpdatePosition));
      fn(window, RESIZE, autoUpdatePosition);
      fn(ROOT, KEY_DOWN, handleKeyboard);
      fn(ROOT, POINTER_DOWN, handleBackdropClick);
      if (shadowRoot) {
        fn(shadowRoot, POINTER_DOWN, handleBackdropClick);
      }
    };
    togglePopoverEvents(addEvent);
    setPosition();
    return {
      _reposition: setPosition,
      _destroy() {
        togglePopoverEvents(removeEvent);
        popoverStyleDeclaration.transform = "";
      }
    };
  };

  const createApp = (alwan, ref) => {
    const {
      config,
      _color: colorState
    } = alwan;
    const root = createDivElement(ALWAN_CLASSNAME);
    const reference = Reference(alwan, getElements(ref)[0]);
    const palette = Palette(alwan);
    const sliders = Sliders(alwan);
    const inputs = Inputs(alwan);
    const components = [palette, {
      _init: config => createDivElement(CONTAINER_CLASSNAME, ...[Utility(alwan), sliders].map(component => component._init(config)))
    }, inputs, Swatches(alwan)];
    let isOpen = false;
    let popoverInstance = null;
    colorState._setUIElements(root, palette, sliders, inputs);
    return {
      _setup(options) {
        options = options || {};
        const self = this;
        const {
          id,
          color
        } = options;
        const {
          theme,
          parent,
          toggle,
          popover,
          target,
          disabled
        } = deepMerge(config, options);
        const refElement = reference._init(config);
        const parentElement = getElements(parent)[0];
        const targetElement = getElements(target)[0];
        colorState._setRef(refElement);
        removeElement(root);
        setInnerHTML(root, "");
        appendChildren(root, ...components.map(component => component._init(config)));
        isString(id) && (root.id = id);
        merge(root.dataset, {
          theme,
          display: popover ? "popover" : "block"
        });

        // Hide reference element if both toggle and popover options are set to false,
        refElement.style.display = popover || toggle ? "" : "none";
        if (popoverInstance) {
          popoverInstance._destroy();
          popoverInstance = null;
        }
        if (popover) {
          appendChildren(parentElement || getBody(), root);
          popoverInstance = createPopover(targetElement || refElement, root, refElement, config, self);
        } else {
          // If there is a target element  or a parent element then append
          // the color picker widget in it, otherwise insert it after the reference element.
          if (targetElement || parentElement) {
            appendChildren(targetElement || parentElement, root);
          } else {
            refElement.after(root);
          }
        }
        if (!toggle) {
          self._toggle(true, true);
        }

        // Disable/Enable color picker.
        [refElement, ...getInteractiveElements(root)].forEach(element => element.disabled = !!disabled);
        if (disabled) {
          if (popover) {
            self._toggle(false, true);
          } else if (!toggle) {
            self._toggle(true, true);
          }
        }
        if (isset(color)) {
          colorState._setColor(color);
        }

        // Update ui.
        colorState._update({}, false, true, true);
      },
      _toggle(state = !isOpen, forced = false) {
        if (state !== isOpen && (!config.disabled || forced && (!state || !config.popover)) && (config.toggle || forced)) {
          if (state && popoverInstance) {
            popoverInstance._reposition();
          }
          isOpen = state;
          toggleClassName(root, OPEN_CLASSNAME, state);
          alwan._events._emit(isOpen ? OPEN : CLOSE);
        }
      },
      _isOpen: () => isOpen,
      _reposition() {
        if (popoverInstance) {
          popoverInstance._reposition();
        }
      },
      _destroy() {
        removeElement(root);
        if (popoverInstance) {
          popoverInstance._destroy();
        }
        reference._destroy();
      }
    };
  };

  const decimalToHex = decimal => (decimal < 16 ? "0" : "") + decimal.toString(16);
  const RGBToHEX = ({
    r,
    g,
    b,
    a
  }) => "#" + decimalToHex(r) + decimalToHex(g) + decimalToHex(b) + (a < 1 ? decimalToHex(round(a * 255)) : "");

  /**
   * Helper function used for converting HSL to RGB.
   */
  const fn = (k, s, l) => {
    k %= 12;
    return round((l - s * min(l, 1 - l) * max(-1, min(k - 3, 9 - k, 1))) * 255);
  };
  const HSLToRGB = ({
    h,
    s,
    l
  }) => {
    h /= 30;
    s /= 100;
    l /= 100;
    return {
      r: fn(h, s, l),
      g: fn(h + 8, s, l),
      b: fn(h + 4, s, l)
    };
  };
  const RGBToHSL = ({
    r,
    g,
    b,
    a
  }) => {
    r /= 255;
    g /= 255;
    b /= 255;
    const cMax = max(r, g, b);
    const cMin = min(r, g, b);
    const d = cMax - cMin;
    const l = (cMax + cMin) / 2;
    const h = d === 0 ? 0 : cMax === r ? (g - b) / d % 6 : cMax === g ? (b - r) / d + 2 : cMax === b ? (r - g) / d + 4 : 0;
    return {
      h: normalizeAngle(h * 60),
      s: d ? d / (1 - abs(2 * l - 1)) * 100 : 0,
      l: l * 100,
      a
    };
  };

  const colorState = alwan => {
    const state = {
      h: 0,
      s: 0,
      l: 0,
      r: 0,
      g: 0,
      b: 0,
      a: 1,
      rgb: "",
      hsl: "",
      hex: ""
    };
    const config = alwan.config;
    const emitEvent = alwan._events._emit;
    let referenceElement;
    let rootElement;
    let paletteComponent;
    let slidersComponent;
    let inputsComponent;
    let currentFormat;
    let cashedColor;
    return {
      _value: state,
      _getColorString: () => state[currentFormat],
      _setFormat(format) {
        currentFormat = config.format = format;
      },
      _setRef(ref) {
        referenceElement = ref;
      },
      _setUIElements(root, palette, sliders, inputs) {
        rootElement = root;
        paletteComponent = palette;
        slidersComponent = sliders;
        inputsComponent = inputs;
      },
      _update(hsl, triggerColorEvent = true, ignoreRGB, updatePaletteAndSliders) {
        const previousHex = state.hex;
        merge(state, hsl);
        !ignoreRGB && merge(state, HSLToRGB(state));
        state.s = round(state.s);
        state.l = round(state.l);
        state.rgb = stringify(state);
        state.hsl = stringify(state, HSL_FORMAT);
        state.hex = RGBToHEX(state);
        setCustomProperty(referenceElement, COLOR, state.rgb);
        setCustomProperty(rootElement, RGB_FORMAT, `${state.r},${state.g},${state.b}`);
        setCustomProperty(rootElement, "a", state.a);
        setCustomProperty(rootElement, "h", state.h);
        inputsComponent._setValues(state);
        if (updatePaletteAndSliders) {
          slidersComponent._setValues(state.h, state.a);
          paletteComponent._updateMarker(state.s, state.l);
        }
        if (triggerColorEvent && previousHex !== state.hex) {
          emitEvent(COLOR, state);
        }
      },
      _setColor(color, triggerColorEvent = false, triggerChangeEvent) {
        const [colorObject, colorFormat] = parseColor(color);
        const isRGB = colorFormat === RGB_FORMAT;
        if (!config.opacity) {
          colorObject.a = 1;
        }
        if (state[colorFormat] !== stringify(colorObject, colorFormat)) {
          merge(state, colorObject, isRGB ? RGBToHSL(colorObject) : {});
          this._update({}, triggerColorEvent, isRGB, true);
          if (triggerChangeEvent) {
            emitEvent(CHANGE, state);
          }
        }
      },
      _cache() {
        cashedColor = state[currentFormat];
      },
      /**
       * Emit change event if the color have changed compared to the cashed color.
       */
      _change() {
        if (cashedColor !== state[currentFormat]) {
          emitEvent(CHANGE, state);
        }
      }
    };
  };

  const Emitter = alwan => {
    const listeners = {
      [OPEN]: [],
      [CLOSE]: [],
      [CHANGE]: [],
      [COLOR]: []
    };
    return {
      _emit(type, value = alwan._color._value) {
        (listeners[type] || []).forEach(listener => listener(merge({
          type,
          source: alwan
        }, value)));
      },
      _on(event, listener) {
        if (listeners[event] && !listeners[event].includes(listener) && isFunction(listener)) {
          listeners[event].push(listener);
        }
      },
      _off(event, listener) {
        if (!isset(event)) {
          // Remove all listeners.
          ObjectForEach(listeners, event => {
            listeners[event] = [];
          });
        } else if (listeners[event]) {
          if (isset(listener)) {
            listeners[event] = listeners[event].filter(fn => fn !== listener);
          } else {
            // Remove all listeners of the given event.
            listeners[event] = [];
          }
        }
      }
    };
  };

  class Alwan {
    static version() {
      return version;
    }
    static setDefaults(defaults) {
      deepMerge(alwanDefaults, defaults);
    }
    constructor(reference, options) {
      this.config = deepMerge({}, alwanDefaults);
      this._events = Emitter(this);
      this._color = colorState(this);
      this._app = createApp(this, reference);
      this._app._setup(options);
    }
    setOptions(options) {
      this._app._setup(options);
    }
    setColor(color) {
      this._color._setColor(color);
      return this;
    }
    getColor() {
      return {
        ...this._color._value
      };
    }
    isOpen() {
      return this._app._isOpen();
    }
    open() {
      this._app._toggle(true);
    }
    close() {
      this._app._toggle(false);
    }
    toggle() {
      this._app._toggle();
    }
    on(type, listener) {
      this._events._on(type, listener);
    }
    off(type, listener) {
      this._events._off(type, listener);
    }
    addSwatches(...swatches) {
      this._app._setup({
        swatches: this.config.swatches.concat(swatches)
      });
    }
    removeSwatches(...swatches) {
      this._app._setup({
        swatches: this.config.swatches.filter((swatch, index) => !swatches.some(item => isNumber(item) ? +item === index : item === swatch))
      });
    }
    enable() {
      this._app._setup({
        disabled: false
      });
    }
    disable() {
      this._app._setup({
        disabled: true
      });
    }
    reset() {
      this._color._setColor(this.config.default);
    }
    reposition() {
      this._app._reposition();
    }
    trigger(type) {
      this._events._emit(type);
    }
    destroy() {
      this._app._destroy();
      ObjectForEach(this, key => delete this[key]);
      setPrototypeOf(this, prototype);
    }
  }

  return Alwan;

})();
