export declare const keys: {
    (o: object): string[];
    (o: {}): string[];
}, merge: {
    <T extends {}, U>(target: T, source: U): T & U;
    <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2 extends {}, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
}, setPrototypeOf: (o: any, proto: object | null) => any, prototype: Object;
export declare const toArray: {
    <T>(arrayLike: ArrayLike<T>): T[];
    <T_1, U>(arrayLike: ArrayLike<T_1>, mapfn: (v: T_1, k: number) => U, thisArg?: any): U[];
    <T_2>(iterable: Iterable<T_2> | ArrayLike<T_2>): T_2[];
    <T_3, U_1>(iterable: Iterable<T_3> | ArrayLike<T_3>, mapfn: (v: T_3, k: number) => U_1, thisArg?: any): U_1[];
}, isArray: (arg: any) => arg is any[];
export declare const isPlainObject: (obj: unknown) => boolean;
export declare const ObjectForEach: <T extends {}>(object: T, callbackFn: (key: keyof T, value: T[keyof T]) => void) => void;
export declare const deepMerge: <T extends {}, U extends {}>(target: T, source: U) => T & U;
